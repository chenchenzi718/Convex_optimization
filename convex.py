# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'convex.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QGraphicsScene
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from scipy.optimize import minimize
from MyConvexSolver import *


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 700)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget.setGeometry(QtCore.QRect(10, 10, 761, 101))
        self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")

        self.pushButton = QtWidgets.QPushButton(self.verticalLayoutWidget)
        self.pushButton.setObjectName("pushButton")
        self.verticalLayout.addWidget(self.pushButton)

        self.pushButton_2 = QtWidgets.QPushButton(self.verticalLayoutWidget)
        self.pushButton_2.setObjectName("pushButton_2")
        self.verticalLayout.addWidget(self.pushButton_2)

        self.pushButton_3 = QtWidgets.QPushButton(self.verticalLayoutWidget)
        self.pushButton_3.setObjectName("pushButton_3")
        self.verticalLayout.addWidget(self.pushButton_3)

        self.graphicsView = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicsView.setGeometry(QtCore.QRect(100, 150, 581, 451))
        self.graphicsView.setObjectName("graphicsView")

        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.pushButton.clicked.connect(self.test_1)
        self.pushButton_2.clicked.connect(self.test_2)
        self.pushButton_3.clicked.connect(self.test_3)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "Test_1"))
        self.pushButton_2.setText(_translate("MainWindow", "Test_2"))
        self.pushButton_3.setText(_translate("MainWindow", "Test_3"))

    def test_1(self):
        x0 = np.array([0.1, 0.1])
        # 建立TestFunc类，根据输入的不同测试函数选择不同的约束条件
        test_func_class = TestFunc(test_func_str="test_1")
        cons, bounds = test_func_class.test_func_constraint()
        test_func = test_func_class.test_func_val

        # 使用内置的minimize求出“精确解”
        res = minimize(test_func, x0, method='SLSQP', bounds=bounds, constraints=cons)
        print(f"result of optimize.minimize function:{res.x}")
        print(f"val of optimize.minimize function:{res.fun}")

        solver = MyConvexSolver(test_func_class)
        x1, _lambda, _gamma = solver.primal_dual_convex_algorithm(x0)

        F = self.pic_my_convex(test_func_class, res.x, solver.myconvex_intermedium_result, test_func_name="test_1")
        width, height = self.graphicsView.width(), self.graphicsView.height()

        self.scene = QGraphicsScene()  # 创建一个场景
        self.canvas = FigureCanvas(F)
        self.scene.addWidget(self.canvas)
        self.graphicsView.setScene(self.scene)  # 将创建添加到图形视图显示窗口

    def test_2(self):
        x0 = np.array([0.1, 1.0])
        # 建立TestFunc类，根据输入的不同测试函数选择不同的约束条件
        test_func_class = TestFunc(test_func_str="test_2")
        cons, bounds = test_func_class.test_func_constraint()
        test_func = test_func_class.test_func_val

        # 使用内置的minimize求出“精确解”
        res = minimize(test_func, x0, method='SLSQP', bounds=bounds, constraints=cons)
        print(f"result of optimize.minimize function:{res.x}")
        print(f"val of optimize.minimize function:{res.fun}")

        solver = MyConvexSolver(test_func_class)
        x1, _lambda, _gamma = solver.primal_dual_convex_algorithm(x0)

        F = self.pic_my_convex(test_func_class, res.x, solver.myconvex_intermedium_result, test_func_name="test_2")
        width, height = self.graphicsView.width(), self.graphicsView.height()

        self.scene = QGraphicsScene()  # 创建一个场景
        self.canvas = FigureCanvas(F)
        self.scene.addWidget(self.canvas)
        self.graphicsView.setScene(self.scene)  # 将创建添加到图形视图显示窗口

    def test_3(self):
        x0 = np.array([0.9, 2.0])
        # 建立TestFunc类，根据输入的不同测试函数选择不同的约束条件
        test_func_class = TestFunc(test_func_str="test_3")
        cons, bounds = test_func_class.test_func_constraint()
        test_func = test_func_class.test_func_val

        # 使用内置的minimize求出“精确解”
        res = minimize(test_func, x0, method='SLSQP', bounds=bounds, constraints=cons)
        print(f"result of optimize.minimize function:{res.x}")
        print(f"val of optimize.minimize function:{res.fun}")

        solver = MyConvexSolver(test_func_class)
        x1, _lambda, _gamma = solver.primal_dual_convex_algorithm(x0)

        F = self.pic_my_convex(test_func_class, res.x, solver.myconvex_intermedium_result, test_func_name="test_3")
        width, height = self.graphicsView.width(), self.graphicsView.height()

        self.scene = QGraphicsScene()  # 创建一个场景
        self.canvas = FigureCanvas(F)
        self.scene.addWidget(self.canvas)
        self.graphicsView.setScene(self.scene)  # 将创建添加到图形视图显示窗口


    # func内为TestFunc类，actual_x输入minimize函数得到的结果，my_convex_medium_x输入的为内点算法函数迭代过程中产生的x_k
    @staticmethod
    def pic_my_convex(func_class: TestFunc, actual_x, my_convex_medium_x, test_func_name="test_1"):
        func = func_class.test_func_val
        dx = 0.01
        dy = 0.01

        if test_func_name == "test_1":
            x = np.arange(-2., 2., dx)
            y = np.arange(-2., 2., dy)
            X, Y = np.meshgrid(x, y)
        elif test_func_name == "test_2":
            x = np.arange(-0.5, 0.5, dx)
            y = np.arange(0.5, 1.5, dy)
            X, Y = np.meshgrid(x, y)
        else:
            x = np.arange(-0.5, 1.5, dx)
            y = np.arange(0, 2.5, dy)
            X, Y = np.meshgrid(x, y)

        y1, y2 = sy.symbols("y1, y2")
        func_sym = func([y1, y2])
        func_val = sy.lambdify([y1, y2], func_sym, 'numpy')

        contour = plt.contour(X, Y, func_val(X, Y), 20)  # 生成等值线图
        plt.contourf(X, Y, func_val(X, Y), 20)
        # plt.clabel(contour, inline=1, fontsize=10)
        plt.colorbar()

        # 一个初值进行绘制
        # 在图上画出最终收敛点
        plt.scatter(actual_x[0], actual_x[1], marker="*", c="y", s=100)

        # 在图上画出在sqp迭代过程中的点
        plt_x = []
        plt_y = []
        for _array in my_convex_medium_x:
            plt_x.append(_array[0])
            plt_y.append(_array[1])
        plt.plot(plt_x, plt_y, "w--")
        plt.title("Primary value x0 iteration in method " + str(test_func_name))

        # 获取当前的Figure对象
        canvas = plt.gcf().canvas

        # 将pyplot图形转换为Figure对象
        figure_object = canvas.figure

        # 关闭pyplot图形
        plt.close()

        return figure_object
